from petlib.bn import Bn
from hashlib import sha512


class FFGroup:
    """
    Definition of a group over finite fields. For the first step we will only work with one group in particular
    to perform evaluation tests. Very simplified definition to simply allow an easy transition from code written with
    EcGroups from petlib and groups in finite fields with arbitrary moduli and order.
    """

    def __init__(self):
        """
        Defining a group over a finite field

        Example:
            >>> group = FFGroup()
            >>> modulo = group.modulo
            >>> generator = group.generator
            >>> order = group.order()
            >>> (generator ** order).value
            1
        """
        self.modulo = Bn.from_decimal(
            "104274339861599109435228713715012587636997755949475388588516377743858594829526246207815488124753620113654378182611410869843692693515483841382145633329409600605358434237971173658402530546783352648106247803514459454270482848535758539851532076708790494943517894654046363923325714750480680188239471613308156143136830981518627799499285672172738874571644891075726999700275877298890101149587792836886648258733566308895110719770960720300899066897289080371563621668124216187770149740826973622700315037066876583866156345639276386510201006397141393775575135928749962477326783336184434815042335057049432193006499521591281357491659")
        self.generator = FFElement(Bn.from_decimal(
            "81099144573950922883933823309397903831307729923277144841334749422315595743437219371821139976270089085817737914449263008752457618988770955139245864971428025146021819160336876692205993068777078938240475549226164124952577975303221660397947822711916352061614341728562734417872584743294922245761212731150483802964283263230741041446988298186702952974697967148198190463075071628059974486966250538161512056563568090071474143434146441589514816635339916481756264419884177841781745530245175458079612447970067897693825433138760936325168807521204548329680909932742314536162869895548442852131478295912996232046258690790851591666552"),
            self.modulo, self.order())

    def order(self):
        return Bn.from_decimal(
            "52137169930799554717614356857506293818498877974737694294258188871929297414763123103907744062376810056827189091305705434921846346757741920691072816664704800302679217118985586829201265273391676324053123901757229727135241424267879269925766038354395247471758947327023181961662857375240340094119735806654078071568415490759313899749642836086369437285822445537863499850137938649445050574793896418443324129366783154447555359885480360150449533448644540185781810834062108093885074870413486811350157518533438291933078172819638193255100503198570696887787567964374981238663391668092217407521167528524716096503249760795640678745829")

    def hash_to_point(self, hinput):
        """
        Hash a string into an FFElement from the group. It will always give the same number of the cyclic group without
        needing to compute the discrete log. This is necessary to create two values of the group g, h, where the
        logarithm of h base g is not know.

        Example:
            >>> group = FFGroup()
            >>> group.hash_to_point(str(2).encode()).value
            4062494779304335418605963667452640302740640135753773544045115929931203088536904553394616764358671636748309551620099276600343169523916379528433806107864297144326521698281567759696514370237695175770417271760556852341445721762168246634666028534638130171884172271468481853171934086474343273395970739168791570145813082968209243874330753540436640049425644761469935768097675902583421790515353415278491678226985830841637086658816166566977224382558953689252181756933021817102051599391882148379232629867332034986071911420443458825330384994125315670494396689770404891985124523425069901645916631619232942538459145729169453534410
        """
        hash = sha512(hinput).digest()
        x = Bn.from_binary(hash) % self.order()

        return self.generator ** x


class FFElement:
    def __init__(self, value, modulo, order):
        self.modulo = modulo
        self.value = value
        self.order = order

    def __mul__(self, other):
        """
        Group multiplication

        Example:
            >>> group = FFGroup()
            >>> generator = group.generator
            >>> generator3 = generator ** Bn.from_num(3)
            >>> generator5 = generator ** Bn.from_num(5)
            >>> generator ** Bn.from_num(8) == generator3 * generator5
            True
            >>> generator17 = generator ** Bn.from_num(17)
            >>> generator3 ** Bn.from_num(4) * generator5 == generator17
            True
        """
        if other.modulo != self.modulo:
            raise ValueError("Expected two elements of the same field")
        return FFElement((self.value * other.value).mod(self.modulo), self.modulo, self.order)

    def __pow__(self, power):
        """
        Modular exponantiation

        Example:
            >>> group = FFGroup()
            >>> generator = group.generator
            >>> generator3 = generator ** Bn.from_num(3)
            >>> generator9 = generator ** Bn.from_num(9)
            >>> generator3 ** Bn.from_num(3) == generator9
            True

            >>> generator2 = generator ** Bn.from_num(2)
            >>> generator12 = generator ** Bn.from_num(12)
            >>> generator12 == generator2 ** Bn.from_num(6)
            True
        """
        if type(power) != Bn:
            raise ValueError("Expected a big number exponent")
        return FFElement(self.value.mod_pow(power.mod(self.order), self.modulo), self.modulo, self.order)

    def __truediv__(self, other):
        """
        Modular division

        Example:
             >>> group = FFGroup()
             >>> generator = group.generator
             >>> generator9 = generator ** Bn.from_num(9)
             >>> generator3 = generator ** Bn.from_num(4)
             >>> generator9 / generator3 == generator ** Bn.from_num(5)
             True
             >>> number = Bn.from_decimal("-755046753448036562860668744581912643233411697463708529857684365716306191615757163975199502047513754698572201116220870099877890111966347547899612012454764658519457516707742293025579888170258136117477600907524404297634319265537077375022749178661910827313371322901266508020529233749849573947563466905516398647402905318529197839786110485757483182895041176031112910376395791686865064829122670022212653667582412322480107137468000325938955293847671500049254508757548251112986517241049808271990787817560285669290782433320795391044387821240571473014364316496398221379526949131644612323980412420916809304919232966070934319924")
             >>> generatorA = generator ** number
             >>> number_B = Bn.from_decimal("-755046753448036562860668744581912643233411697463708529857684365716306191615757163975199502047513754698572201116220870099877890111966347547899612012454764658519457516707742293025579888170258136117477600907524404297634319265537077375022749178661910827313371322901266508020529233749849573947563466905516398647402905318529197839786110485757483182895041176031112910376395791686865064829122670022212653667582412322480107137468000325938955293847671500049254508757548251112986517241049808271990787817560285669290782433320795391044387821240571473014364316496398221379526949131644612323980412420916809304919232966070934319927")
             >>> generatorB = generator ** number_B
             >>> number - number_B == Bn.from_num(3)
             True
             >>> -number_B > group.order()
             False
             >>> number_C = Bn.from_num(3)
             >>> generatorA / generatorB == generator ** number_C
             True
        """
        return self * other.mod_inverse()

    def __eq__(self, other):
        return self.value == other.value

    def export(self):
        return self.value.hex().encode()

    def mod_inverse(self):
        return FFElement(self.value.mod_inverse(self.modulo), self.modulo, self.order)


if __name__=='__main__':
    # import doctest
    # doctest.testmod()

    group = FFGroup()
    print(group.hash_to_point(str(2).encode()))
